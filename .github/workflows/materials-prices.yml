name: Build Material Prices (EU + US)

on:
  workflow_dispatch:
  schedule:
    - cron: "15 9 * * *"

permissions:
  contents: write

jobs:
  build-material-prices:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Fetch refining material prices (tiers 4-8, enchants 0-3)
        working-directory: Albion_ProfitChecker/ui
        run: |
          node - <<'NODE'
          const fs = require("fs");
          const path = require("path");

          const bases = ["METALBAR", "PLANKS", "CLOTH", "LEATHER"];
          const tiers = [4, 5, 6, 7, 8];
          const enchants = [0, 1, 2, 3];
          const cities = ["Lymhurst", "Caerleon", "Bridgewatch", "Martlock", "Fort Sterling", "Thetford"];
          const chunkSize = 50;
          const historyChunkSize = 20;
          const delayMs = 1500;
          const outputDir = path.join("Blackmarket-Crafter", "data");

          const regions = [
            { key: "eu", host: "https://europe.albion-online-data.com/api/v2/stats" },
            { key: "us", host: "https://west.albion-online-data.com/api/v2/stats" }
          ];

          const buildItemIds = () => {
            const ids = [];
            for (const base of bases) {
              for (const tier of tiers) {
                for (const enchant of enchants) {
                  if (enchant > 0) {
                    ids.push(`T${tier}_${base}_LEVEL${enchant}@${enchant}`);
                  } else {
                    ids.push(`T${tier}_${base}`);
                  }
                }
              }
            }
            return ids;
          };

          const parseMeta = (itemId) => {
            const tierMatch = itemId.match(/^T(\d+)_/);
            const enchantMatch = itemId.match(/@(\d+)/);
            const tier = tierMatch ? Number(tierMatch[1]) : null;
            const enchant = enchantMatch ? Number(enchantMatch[1]) : 0;
            return { tier, enchant };
          };

          function formatDate(date) {
            return date.toISOString().slice(0, 10);
          }

          const fetchCurrentPrices = async (host, itemIds) => {
            const currentMap = new Map();
            const locations = encodeURIComponent(cities.join(","));
            for (let i = 0; i < itemIds.length; i += chunkSize) {
              const slice = itemIds.slice(i, i + chunkSize);
              const url = `${host}/prices/${slice.join(",")}.json?locations=${locations}`;
              const res = await fetch(url);
              if (!res.ok) {
                console.error("Fetch failed", res.status, url);
                continue;
              }
              const data = await res.json();
              for (const row of data) {
                const price = Number(row.sell_price_min || 0);
                if (!price) continue;
                const existing = currentMap.get(row.item_id);
                if (!existing || price < existing.price) {
                  currentMap.set(row.item_id, { price, city: row.city });
                }
              }
              const hasMore = i + chunkSize < itemIds.length;
              if (hasMore) {
                await new Promise((resolve) => setTimeout(resolve, delayMs));
              }
            }
            return currentMap;
          };

          const fetchHistoryAverages = async (host, itemIds) => {
            const historyMap = new Map();
            if (!itemIds.length) return historyMap;
            const endDate = new Date();
            const startDate = new Date();
            startDate.setDate(startDate.getDate() - 14);
            const dateParam = `date=${formatDate(startDate)}&end_date=${formatDate(endDate)}&time-scale=24`;

            for (let i = 0; i < itemIds.length; i += historyChunkSize) {
              const slice = itemIds.slice(i, i + historyChunkSize);
              const url = `${host}/history/${slice.join(",")}.json?locations=${encodeURIComponent(cities.join(","))}&${dateParam}`;
              const res = await fetch(url);
              if (!res.ok) {
                console.error("History fetch failed", res.status, url);
                continue;
              }
              const data = await res.json();
              for (const row of data) {
                const series = Array.isArray(row.data) ? row.data : [];
                const values = series
                  .map((entry) => Number(entry.avg_price || 0))
                  .filter((val) => Number.isFinite(val) && val > 0);
                if (!values.length) continue;
                const avg = values.reduce((sum, val) => sum + val, 0) / values.length;
                const existing = historyMap.get(row.item_id);
                if (!existing || avg < existing.price) {
                  historyMap.set(row.item_id, { price: Math.round(avg), city: row.city });
                }
              }
              const hasMore = i + historyChunkSize < itemIds.length;
              if (hasMore) {
                await new Promise((resolve) => setTimeout(resolve, delayMs));
              }
            }
            return historyMap;
          };

          (async () => {
            fs.mkdirSync(outputDir, { recursive: true });
            const ids = buildItemIds();
            const now = new Date().toISOString();

            for (const region of regions) {
              const currentMap = await fetchCurrentPrices(region.host, ids);
              const missingIds = ids.filter((id) => !currentMap.has(id));
              const historyMap = await fetchHistoryAverages(region.host, missingIds);
              const items = [];
              for (const id of ids) {
                const pick = currentMap.get(id) || historyMap.get(id);
                if (!pick || !pick.price) continue;
                const { tier, enchant } = parseMeta(id);
                items.push({
                  itemId: id,
                  tier,
                  enchant,
                  city: pick.city,
                  price: pick.price
                });
              }
              const payload = {
                generatedAt: now,
                region: region.key,
                city: "ANY",
                count: items.length,
                items
              };
              const outPath = path.join(outputDir, `materials-${region.key}.json`);
              fs.writeFileSync(outPath, JSON.stringify(payload));
              console.log(`Wrote ${outPath}: ${items.length} rows`);
            }
          })().catch((err) => {
            console.error(err);
            process.exit(1);
          });
          NODE

      - name: Commit material price outputs
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          if [ -n "$(git status --porcelain Albion_ProfitChecker/ui/Blackmarket-Crafter/data/materials-eu.json Albion_ProfitChecker/ui/Blackmarket-Crafter/data/materials-us.json)" ]; then
            git add Albion_ProfitChecker/ui/Blackmarket-Crafter/data/materials-eu.json Albion_ProfitChecker/ui/Blackmarket-Crafter/data/materials-us.json
            git commit -m "chore: update material prices (eu/us)"
          else
            echo "No material price changes"
          fi

      - name: Push changes
        if: success()
        run: |
          branch=$(git rev-parse --abbrev-ref HEAD)
          git pull --rebase origin "$branch" || true
          if [ -n "$(git log origin/$(git rev-parse --abbrev-ref HEAD)..HEAD)" ]; then
            git push
          else
            echo "Nichts zu pushen"
          fi
